# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ

## 1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶ãƒ»è„…å¨ãƒ¢ãƒ‡ãƒ«

### 1.1 ä¿è­·å¯¾è±¡è³‡ç”£

```
æ©Ÿå¯†ãƒ¬ãƒ™ãƒ«: é«˜
â”œâ”€â”€ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿
â”‚   â”œâ”€â”€ å­¦ç¿’å±¥æ­´ãƒ»é€²æ—æƒ…å ±
â”‚   â”œâ”€â”€ å€‹äººãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±
â”‚   â””â”€â”€ AIåˆ†æçµæœãƒ»ã‚¤ãƒ³ã‚µã‚¤ãƒˆ
â”œâ”€â”€ èªè¨¼æƒ…å ±
â”‚   â”œâ”€â”€ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ»ç”Ÿä½“èªè¨¼ãƒ‡ãƒ¼ã‚¿
â”‚   â”œâ”€â”€ ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒˆãƒ¼ã‚¯ãƒ³
â”‚   â””â”€â”€ OAuthèªè¨¼æƒ…å ±
â””â”€â”€ ã‚·ã‚¹ãƒ†ãƒ æ©Ÿå¯†æƒ…å ±
    â”œâ”€â”€ OpenAI APIã‚­ãƒ¼
    â”œâ”€â”€ Firebaseè¨­å®šæƒ…å ±
    â””â”€â”€ æš—å·åŒ–ã‚­ãƒ¼

æ©Ÿå¯†ãƒ¬ãƒ™ãƒ«: ä¸­
â”œâ”€â”€ ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ãƒ‡ãƒ¼ã‚¿
â”‚   â”œâ”€â”€ ã‚¢ãƒ—ãƒªåˆ©ç”¨çµ±è¨ˆ
â”‚   â”œâ”€â”€ ç”»é¢é·ç§»ãƒ­ã‚°
â”‚   â””â”€â”€ ã‚¨ãƒ©ãƒ¼ãƒ»ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ãƒ­ã‚°
â””â”€â”€ ã‚·ã‚¹ãƒ†ãƒ è¨­å®šæƒ…å ±
    â”œâ”€â”€ ç’°å¢ƒè¨­å®š
    â””â”€â”€ æ©Ÿèƒ½ãƒ•ãƒ©ã‚°

æ©Ÿå¯†ãƒ¬ãƒ™ãƒ«: ä½
â”œâ”€â”€ å…¬é–‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
â”‚   â”œâ”€â”€ ä¸€èˆ¬çš„ãªå­¦ç¿’ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
â”‚   â””â”€â”€ ãƒ˜ãƒ«ãƒ—ãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
â””â”€â”€ åŒ¿ååŒ–çµ±è¨ˆãƒ‡ãƒ¼ã‚¿
```

### 1.2 è„…å¨ãƒ¢ãƒ‡ãƒ« (STRIDEåˆ†æ)

| è„…å¨ã‚«ãƒ†ã‚´ãƒª | å…·ä½“çš„è„…å¨ | å½±éŸ¿ | å¯¾ç­– |
|------------|-----------|------|------|
| **Spoofing** | ãªã‚Šã™ã¾ã—ãƒ­ã‚°ã‚¤ãƒ³ | å€‹äººãƒ‡ãƒ¼ã‚¿æ¼æ´© | å¤šè¦ç´ èªè¨¼ã€ç”Ÿä½“èªè¨¼ |
| **Tampering** | ãƒ‡ãƒ¼ã‚¿æ”¹ã–ã‚“ | å­¦ç¿’é€²æ—ã®ä¸æ­£æ“ä½œ | ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã€ç›£æŸ»ãƒ­ã‚° |
| **Repudiation** | æ“ä½œã®å¦èª | ãƒˆãƒ©ãƒ–ãƒ«æ™‚ã®è¿½è·¡å›°é›£ | è©³ç´°ãªç›£æŸ»ãƒ­ã‚°ã€ãƒ‡ã‚¸ã‚¿ãƒ«ç½²å |
| **Information Disclosure** | ãƒ‡ãƒ¼ã‚¿æ¼æ´© | ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¾µå®³ | æš—å·åŒ–ã€ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ |
| **Denial of Service** | ã‚µãƒ¼ãƒ“ã‚¹å¦¨å®³ | ã‚¢ãƒ—ãƒªåˆ©ç”¨ä¸å¯ | ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã€ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ  |
| **Elevation of Privilege** | æ¨©é™æ˜‡æ ¼ | ä¸æ­£ãªç®¡ç†æ©Ÿèƒ½ã‚¢ã‚¯ã‚»ã‚¹ | æœ€å°æ¨©é™ã®åŸå‰‡ã€æ¨©é™æ¤œè¨¼ |

## 2. èªè¨¼ãƒ»èªå¯ã‚·ã‚¹ãƒ†ãƒ 

### 2.1 Firebase Authenticationçµ±åˆ

```typescript
// services/auth/authService.ts
import { 
  Auth, 
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  User,
  updateProfile,
  reauthenticateWithCredential,
  EmailAuthProvider
} from 'firebase/auth';
import * as LocalAuthentication from 'expo-local-authentication';
import * as SecureStore from 'expo-secure-store';

interface AuthResult {
  user: User | null;
  token?: string;
  biometricEnabled?: boolean;
}

class AuthService {
  private auth: Auth;
  private currentUser: User | null = null;
  
  constructor(auth: Auth) {
    this.auth = auth;
    this.initializeAuthListener();
  }

  // èªè¨¼çŠ¶æ…‹ãƒªã‚¹ãƒŠãƒ¼
  private initializeAuthListener(): void {
    onAuthStateChanged(this.auth, async (user) => {
      this.currentUser = user;
      
      if (user) {
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’ã‚¹ãƒˆã‚¢ã«ä¿å­˜
        const userProfile = await this.fetchUserProfile(user.uid);
        useUserStore.getState().setProfile(userProfile);
        
        // ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å®‰å…¨ã«ä¿å­˜
        const token = await user.getIdToken();
        await this.securelyStoreToken(token);
        
        // ç”Ÿä½“èªè¨¼ã®è¨­å®šãƒã‚§ãƒƒã‚¯
        await this.checkBiometricSetup(user.uid);
      } else {
        // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆæ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        await this.cleanupUserSession();
      }
    });
  }

  // ãƒ¡ãƒ¼ãƒ«ãƒ»ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ­ã‚°ã‚¤ãƒ³
  async signInWithEmail(email: string, password: string): Promise<AuthResult> {
    try {
      // å…¥åŠ›å€¤ã®æ¤œè¨¼
      this.validateEmailAndPassword(email, password);
      
      const result = await signInWithEmailAndPassword(this.auth, email, password);
      const token = await result.user.getIdToken();
      
      // ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ã®ç›£æŸ»ãƒ­ã‚°
      this.logSecurityEvent('login_success', {
        userId: result.user.uid,
        method: 'email',
        timestamp: new Date(),
      });
      
      return {
        user: result.user,
        token,
      };
    } catch (error) {
      // ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—æ™‚ã®ç›£æŸ»ãƒ­ã‚°
      this.logSecurityEvent('login_failed', {
        email,
        error: error.code,
        timestamp: new Date(),
      });
      
      throw this.handleAuthError(error);
    }
  }

  // ç”Ÿä½“èªè¨¼ãƒ­ã‚°ã‚¤ãƒ³
  async signInWithBiometrics(): Promise<AuthResult> {
    try {
      // ç”Ÿä½“èªè¨¼ã®å¯ç”¨æ€§ãƒã‚§ãƒƒã‚¯
      const isAvailable = await LocalAuthentication.hasHardwareAsync();
      if (!isAvailable) {
        throw new Error('Biometric authentication not available');
      }
      
      const isEnrolled = await LocalAuthentication.isEnrolledAsync();
      if (!isEnrolled) {
        throw new Error('No biometric data enrolled');
      }
      
      // ç”Ÿä½“èªè¨¼å®Ÿè¡Œ
      const biometricResult = await LocalAuthentication.authenticateAsync({
        promptMessage: 'Authenticate to access Climb You',
        subtitle: 'Use your fingerprint or face to sign in',
        cancelLabel: 'Cancel',
        fallbackLabel: 'Use password instead',
        requireConfirmation: true,
      });
      
      if (!biometricResult.success) {
        throw new Error('Biometric authentication failed');
      }
      
      // ä¿å­˜ã•ã‚ŒãŸèªè¨¼æƒ…å ±ã‚’å–å¾—
      const storedToken = await SecureStore.getItemAsync('user_token');
      if (!storedToken) {
        throw new Error('No stored authentication found');
      }
      
      // ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æ€§ã‚’æ¤œè¨¼
      const isValid = await this.validateStoredToken(storedToken);
      if (!isValid) {
        // ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ãªå ´åˆã¯å†ãƒ­ã‚°ã‚¤ãƒ³ã‚’è¦æ±‚
        await this.clearStoredCredentials();
        throw new Error('Stored authentication expired');
      }
      
      this.logSecurityEvent('login_success', {
        userId: this.currentUser?.uid,
        method: 'biometric',
        timestamp: new Date(),
      });
      
      return {
        user: this.currentUser,
        token: storedToken,
        biometricEnabled: true,
      };
    } catch (error) {
      this.logSecurityEvent('biometric_login_failed', {
        error: error.message,
        timestamp: new Date(),
      });
      throw error;
    }
  }

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
  async registerWithEmail(email: string, password: string, profile: UserProfile): Promise<AuthResult> {
    try {
      this.validateEmailAndPassword(email, password);
      this.validateUserProfile(profile);
      
      const result = await createUserWithEmailAndPassword(this.auth, email, password);
      
      // ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’æ›´æ–°
      await updateProfile(result.user, {
        displayName: profile.name,
      });
      
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’Firestoreã«ä¿å­˜
      await this.createUserProfile(result.user.uid, profile);
      
      const token = await result.user.getIdToken();
      
      this.logSecurityEvent('registration_success', {
        userId: result.user.uid,
        timestamp: new Date(),
      });
      
      return {
        user: result.user,
        token,
      };
    } catch (error) {
      this.logSecurityEvent('registration_failed', {
        email,
        error: error.code,
        timestamp: new Date(),
      });
      throw this.handleAuthError(error);
    }
  }

  // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
  async signOut(): Promise<void> {
    try {
      const userId = this.currentUser?.uid;
      
      await signOut(this.auth);
      await this.cleanupUserSession();
      
      this.logSecurityEvent('logout', {
        userId,
        timestamp: new Date(),
      });
    } catch (error) {
      console.error('Logout error:', error);
      throw error;
    }
  }

  // ãƒˆãƒ¼ã‚¯ãƒ³æ›´æ–°
  async refreshToken(): Promise<string> {
    if (!this.currentUser) {
      throw new Error('No authenticated user');
    }
    
    try {
      const token = await this.currentUser.getIdToken(true); // å¼·åˆ¶æ›´æ–°
      await this.securelyStoreToken(token);
      return token;
    } catch (error) {
      console.error('Token refresh failed:', error);
      throw error;
    }
  }

  // ç”Ÿä½“èªè¨¼è¨­å®š
  async enableBiometricAuth(): Promise<void> {
    if (!this.currentUser) {
      throw new Error('User must be authenticated');
    }
    
    const isAvailable = await LocalAuthentication.hasHardwareAsync();
    if (!isAvailable) {
      throw new Error('Biometric hardware not available');
    }
    
    const isEnrolled = await LocalAuthentication.isEnrolledAsync();
    if (!isEnrolled) {
      throw new Error('No biometric data enrolled on device');
    }
    
    // ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§å†èªè¨¼
    const password = await this.promptForCurrentPassword();
    const credential = EmailAuthProvider.credential(
      this.currentUser.email!,
      password
    );
    
    await reauthenticateWithCredential(this.currentUser, credential);
    
    // ç”Ÿä½“èªè¨¼æœ‰åŠ¹åŒ–ãƒ•ãƒ©ã‚°ã‚’ä¿å­˜
    await SecureStore.setItemAsync('biometric_enabled', 'true');
    
    this.logSecurityEvent('biometric_enabled', {
      userId: this.currentUser.uid,
      timestamp: new Date(),
    });
  }

  // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰
  private validateEmailAndPassword(email: string, password: string): void {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      throw new Error('Invalid email format');
    }
    
    if (password.length < 8) {
      throw new Error('Password must be at least 8 characters');
    }
    
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
    
    const strengthScore = [hasUpperCase, hasLowerCase, hasNumbers, hasSpecialChar]
      .filter(Boolean).length;
    
    if (strengthScore < 3) {
      throw new Error('Password must contain at least 3 of: uppercase, lowercase, numbers, special characters');
    }
  }

  private async securelyStoreToken(token: string): Promise<void> {
    await SecureStore.setItemAsync('user_token', token, {
      requireAuthentication: true,
      authenticationPrompt: 'Authenticate to access your account',
    });
  }

  private async validateStoredToken(token: string): Promise<boolean> {
    try {
      // Firebaseã§ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æ€§ã‚’æ¤œè¨¼
      const decodedToken = await admin.auth().verifyIdToken(token);
      return decodedToken.exp > Date.now() / 1000;
    } catch {
      return false;
    }
  }

  private async cleanupUserSession(): Promise<void> {
    await SecureStore.deleteItemAsync('user_token').catch(() => {});
    await SecureStore.deleteItemAsync('biometric_enabled').catch(() => {});
    
    // ã‚¹ãƒˆã‚¢ã®ã‚¯ãƒªã‚¢
    useUserStore.getState().reset();
    useQuestStore.getState().reset();
    useAIStore.getState().reset();
  }

  private handleAuthError(error: any): Error {
    switch (error.code) {
      case 'auth/user-not-found':
      case 'auth/wrong-password':
        return new Error('Invalid email or password');
      case 'auth/email-already-in-use':
        return new Error('Email already registered');
      case 'auth/weak-password':
        return new Error('Password is too weak');
      case 'auth/too-many-requests':
        return new Error('Too many failed attempts. Please try again later');
      default:
        return new Error('Authentication failed. Please try again');
    }
  }

  private logSecurityEvent(event: string, data: any): void {
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°
    console.log(`ğŸ”’ Security Event: ${event}`, data);
    
    // æœ¬ç•ªç’°å¢ƒã§ã¯ç›£æŸ»ãƒ­ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã«é€ä¿¡
    if (!__DEV__) {
      this.sendAuditLog(event, data);
    }
  }

  private async sendAuditLog(event: string, data: any): Promise<void> {
    try {
      await fetch('/api/audit/security-events', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          event,
          data: {
            ...data,
            appVersion: Constants.expoConfig?.version,
            platform: Platform.OS,
            deviceId: await Application.getInstallationTimeAsync(),
          },
        }),
      });
    } catch (error) {
      console.error('Failed to send audit log:', error);
    }
  }
}

export const authService = new AuthService(auth);
```

### 2.2 ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†

```typescript
// services/auth/sessionManager.ts
interface SessionInfo {
  userId: string;
  token: string;
  expiresAt: Date;
  deviceId: string;
  ipAddress?: string;
}

class SessionManager {
  private sessions = new Map<string, SessionInfo>();
  private readonly SESSION_TIMEOUT = 24 * 60 * 60 * 1000; // 24æ™‚é–“
  private readonly IDLE_TIMEOUT = 30 * 60 * 1000; // 30åˆ†
  private idleTimer: NodeJS.Timeout | null = null;
  private lastActivity = Date.now();

  async createSession(userId: string, token: string): Promise<string> {
    const sessionId = generateUUID();
    const deviceId = await this.getDeviceId();
    
    const sessionInfo: SessionInfo = {
      userId,
      token,
      expiresAt: new Date(Date.now() + this.SESSION_TIMEOUT),
      deviceId,
    };
    
    this.sessions.set(sessionId, sessionInfo);
    
    // ã‚¢ã‚¤ãƒ‰ãƒ«ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
    this.startIdleTimer();
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ã‚’æš—å·åŒ–ã—ã¦ä¿å­˜
    await this.storeSessionSecurely(sessionId, sessionInfo);
    
    return sessionId;
  }

  async validateSession(sessionId: string): Promise<boolean> {
    const session = this.sessions.get(sessionId) || 
                   await this.loadSessionFromStorage(sessionId);
    
    if (!session) {
      return false;
    }
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯
    if (session.expiresAt < new Date()) {
      await this.destroySession(sessionId);
      return false;
    }
    
    // ãƒ‡ãƒã‚¤ã‚¹IDã®æ¤œè¨¼
    const currentDeviceId = await this.getDeviceId();
    if (session.deviceId !== currentDeviceId) {
      await this.destroySession(sessionId);
      return false;
    }
    
    // æœ€çµ‚ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£æ›´æ–°
    this.updateLastActivity();
    
    return true;
  }

  async refreshSession(sessionId: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.expiresAt = new Date(Date.now() + this.SESSION_TIMEOUT);
      await this.storeSessionSecurely(sessionId, session);
    }
  }

  async destroySession(sessionId: string): Promise<void> {
    this.sessions.delete(sessionId);
    await SecureStore.deleteItemAsync(`session_${sessionId}`);
    
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
      this.idleTimer = null;
    }
  }

  private updateLastActivity(): void {
    this.lastActivity = Date.now();
    this.startIdleTimer();
  }

  private startIdleTimer(): void {
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
    }
    
    this.idleTimer = setTimeout(() => {
      this.handleIdleTimeout();
    }, this.IDLE_TIMEOUT);
  }

  private async handleIdleTimeout(): Promise<void> {
    // ã‚¢ã‚¤ãƒ‰ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®å‡¦ç†
    useUIStore.getState().showIdleWarning();
    
    // ã•ã‚‰ã«5åˆ†å¾Œã«è‡ªå‹•ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
    setTimeout(async () => {
      await authService.signOut();
      useUIStore.getState().showMessage({
        type: 'info',
        title: 'Session Expired',
        message: 'You have been logged out due to inactivity',
      });
    }, 5 * 60 * 1000);
  }

  private async getDeviceId(): Promise<string> {
    let deviceId = await SecureStore.getItemAsync('device_id');
    if (!deviceId) {
      deviceId = generateUUID();
      await SecureStore.setItemAsync('device_id', deviceId);
    }
    return deviceId;
  }

  private async storeSessionSecurely(sessionId: string, session: SessionInfo): Promise<void> {
    const encrypted = await this.encryptSessionData(session);
    await SecureStore.setItemAsync(`session_${sessionId}`, encrypted);
  }

  private async loadSessionFromStorage(sessionId: string): Promise<SessionInfo | null> {
    try {
      const encrypted = await SecureStore.getItemAsync(`session_${sessionId}`);
      if (!encrypted) return null;
      
      return await this.decryptSessionData(encrypted);
    } catch (error) {
      console.error('Failed to load session from storage:', error);
      return null;
    }
  }
}

export const sessionManager = new SessionManager();
```

## 3. ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–

### 3.1 æš—å·åŒ–ã‚µãƒ¼ãƒ“ã‚¹

```typescript
// services/encryption/encryptionService.ts
import * as Crypto from 'expo-crypto';
import * as SecureStore from 'expo-secure-store';

interface EncryptedData {
  data: string;
  iv: string;
  tag: string;
}

class EncryptionService {
  private readonly ALGORITHM = 'aes-256-gcm';
  private readonly KEY_LENGTH = 32; // 256 bits
  private readonly IV_LENGTH = 12;  // 96 bits for GCM
  
  // ãƒã‚¹ã‚¿ãƒ¼ã‚­ãƒ¼ã®ç”Ÿæˆãƒ»å–å¾—
  async getMasterKey(): Promise<string> {
    let masterKey = await SecureStore.getItemAsync('master_key');
    
    if (!masterKey) {
      // æ–°ã—ã„ãƒã‚¹ã‚¿ãƒ¼ã‚­ãƒ¼ã‚’ç”Ÿæˆ
      const keyBuffer = await Crypto.getRandomBytesAsync(this.KEY_LENGTH);
      masterKey = Array.from(new Uint8Array(keyBuffer))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
      
      await SecureStore.setItemAsync('master_key', masterKey, {
        requireAuthentication: true,
        authenticationPrompt: 'Authenticate to access encryption key',
      });
    }
    
    return masterKey;
  }

  // ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–
  async encryptData(plaintext: string, keyId?: string): Promise<EncryptedData> {
    try {
      const key = keyId ? await this.getDerivedKey(keyId) : await this.getMasterKey();
      const keyBuffer = this.hexToBuffer(key);
      const plaintextBuffer = new TextEncoder().encode(plaintext);
      
      // ãƒ©ãƒ³ãƒ€ãƒ IVã‚’ç”Ÿæˆ
      const iv = await Crypto.getRandomBytesAsync(this.IV_LENGTH);
      
      // AES-256-GCMã§æš—å·åŒ–
      const encrypted = await this.aesGcmEncrypt(plaintextBuffer, keyBuffer, iv);
      
      return {
        data: this.bufferToHex(encrypted.data),
        iv: this.bufferToHex(iv),
        tag: this.bufferToHex(encrypted.tag),
      };
    } catch (error) {
      console.error('Encryption failed:', error);
      throw new Error('Data encryption failed');
    }
  }

  // ãƒ‡ãƒ¼ã‚¿å¾©å·åŒ–
  async decryptData(encryptedData: EncryptedData, keyId?: string): Promise<string> {
    try {
      const key = keyId ? await this.getDerivedKey(keyId) : await this.getMasterKey();
      const keyBuffer = this.hexToBuffer(key);
      const dataBuffer = this.hexToBuffer(encryptedData.data);
      const ivBuffer = this.hexToBuffer(encryptedData.iv);
      const tagBuffer = this.hexToBuffer(encryptedData.tag);
      
      // AES-256-GCMã§å¾©å·åŒ–
      const decrypted = await this.aesGcmDecrypt({
        data: dataBuffer,
        tag: tagBuffer,
      }, keyBuffer, ivBuffer);
      
      return new TextDecoder().decode(decrypted);
    } catch (error) {
      console.error('Decryption failed:', error);
      throw new Error('Data decryption failed');
    }
  }

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼å›ºæœ‰ã®æ´¾ç”Ÿã‚­ãƒ¼ã‚’ç”Ÿæˆ
  async getDerivedKey(userId: string): Promise<string> {
    const masterKey = await this.getMasterKey();
    const salt = `climb_you_${userId}`;
    
    // PBKDF2ã§ã‚­ãƒ¼æ´¾ç”Ÿ
    const derivedKey = await this.pbkdf2(masterKey, salt, 100000, this.KEY_LENGTH);
    return this.bufferToHex(derivedKey);
  }

  // ãƒãƒƒã‚·ãƒ¥é–¢æ•°
  async hashData(data: string, salt?: string): Promise<string> {
    const input = salt ? `${data}${salt}` : data;
    const hash = await Crypto.digestStringAsync(
      Crypto.CryptoDigestAlgorithm.SHA256,
      input,
      { encoding: Crypto.CryptoEncoding.HEX }
    );
    return hash;
  }

  // ãƒ‡ã‚¸ã‚¿ãƒ«ç½²åã®æ¤œè¨¼
  async verifyDataIntegrity(data: string, expectedHash: string): Promise<boolean> {
    const actualHash = await this.hashData(data);
    return actualHash === expectedHash;
  }

  // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå®Ÿè£…ã¯ç°¡ç•¥åŒ–ï¼‰
  private async aesGcmEncrypt(
    plaintext: Uint8Array, 
    key: Uint8Array, 
    iv: Uint8Array
  ): Promise<{ data: Uint8Array; tag: Uint8Array }> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ crypto ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨
    // React Nativeç’°å¢ƒã§ã¯é©åˆ‡ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
    throw new Error('AES-GCM implementation required');
  }

  private async aesGcmDecrypt(
    encrypted: { data: Uint8Array; tag: Uint8Array },
    key: Uint8Array,
    iv: Uint8Array
  ): Promise<Uint8Array> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ crypto ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨
    throw new Error('AES-GCM implementation required');
  }

  private async pbkdf2(
    password: string,
    salt: string,
    iterations: number,
    keyLength: number
  ): Promise<Uint8Array> {
    // PBKDF2å®Ÿè£…
    throw new Error('PBKDF2 implementation required');
  }

  private hexToBuffer(hex: string): Uint8Array {
    return new Uint8Array(hex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));
  }

  private bufferToHex(buffer: Uint8Array): string {
    return Array.from(buffer)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
}

export const encryptionService = new EncryptionService();
```

### 3.2 ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–

```typescript
// services/storage/secureStorage.ts
class SecureStorage {
  // æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–ä¿å­˜
  async setSecureItem(key: string, value: any, userId?: string): Promise<void> {
    try {
      const jsonValue = JSON.stringify(value);
      const encrypted = await encryptionService.encryptData(
        jsonValue, 
        userId // ãƒ¦ãƒ¼ã‚¶ãƒ¼å›ºæœ‰ã®ã‚­ãƒ¼ã‚’ä½¿ç”¨
      );
      
      const encryptedString = JSON.stringify(encrypted);
      await SecureStore.setItemAsync(`secure_${key}`, encryptedString);
      
      // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®ãŸã‚ã®ãƒãƒƒã‚·ãƒ¥ã‚‚ä¿å­˜
      const hash = await encryptionService.hashData(jsonValue);
      await SecureStore.setItemAsync(`hash_${key}`, hash);
    } catch (error) {
      console.error('Secure storage write failed:', error);
      throw new Error('Failed to store secure data');
    }
  }

  // æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã®å¾©å·åŒ–å–å¾—
  async getSecureItem<T>(key: string, userId?: string): Promise<T | null> {
    try {
      const encryptedString = await SecureStore.getItemAsync(`secure_${key}`);
      if (!encryptedString) return null;
      
      const encrypted: EncryptedData = JSON.parse(encryptedString);
      const decrypted = await encryptionService.decryptData(encrypted, userId);
      
      // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®æ¤œè¨¼
      const expectedHash = await SecureStore.getItemAsync(`hash_${key}`);
      if (expectedHash) {
        const isValid = await encryptionService.verifyDataIntegrity(
          decrypted, 
          expectedHash
        );
        if (!isValid) {
          throw new Error('Data integrity check failed');
        }
      }
      
      return JSON.parse(decrypted) as T;
    } catch (error) {
      console.error('Secure storage read failed:', error);
      return null;
    }
  }

  // ã‚»ã‚­ãƒ¥ã‚¢ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤
  async removeSecureItem(key: string): Promise<void> {
    await SecureStore.deleteItemAsync(`secure_${key}`);
    await SecureStore.deleteItemAsync(`hash_${key}`);
  }

  // ã™ã¹ã¦ã®ã‚»ã‚­ãƒ¥ã‚¢ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
  async clearAllSecureData(): Promise<void> {
    const keys = await this.getAllSecureKeys();
    await Promise.all(keys.map(key => this.removeSecureItem(key)));
  }

  private async getAllSecureKeys(): Promise<string[]> {
    // å®Ÿè£…ã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ãªã‚­ãƒ¼åˆ—æŒ™æ–¹æ³•ã‚’ä½¿ç”¨
    return [];
  }
}

export const secureStorage = new SecureStorage();
```

## 4. é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### 4.1 HTTPSã¨SSL Pinning

```typescript
// services/network/secureApiClient.ts
class SecureApiClient {
  private baseURL: string;
  private expectedCertFingerprint: string;
  
  constructor(baseURL: string, certFingerprint: string) {
    this.baseURL = baseURL;
    this.expectedCertFingerprint = certFingerprint;
  }

  async secureRequest<T>(
    endpoint: string, 
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseURL}${endpoint}`;
    
    // SSLè¨¼æ˜æ›¸ãƒ”ãƒ³ç•™ã‚ã®å®Ÿè£…
    const response = await this.performPinnedRequest(url, options);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
  }

  private async performPinnedRequest(url: string, options: RequestInit): Promise<Response> {
    // React Nativeç’°å¢ƒã§ã®è¨¼æ˜æ›¸ãƒ”ãƒ³ç•™ã‚å®Ÿè£…
    // react-native-ssl-pinning ãªã©ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
    
    const pinnedOptions = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'X-API-Version': '1.0',
        ...options.headers,
      },
      // SSL Pinningè¨­å®š
      sslPinning: {
        certs: [this.expectedCertFingerprint],
      },
    };
    
    return fetch(url, pinnedOptions);
  }

  // OpenAI APIã¸ã®ã‚»ã‚­ãƒ¥ã‚¢ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
  async openAIRequest(prompt: string, model: string = 'gpt-4o'): Promise<any> {
    const apiKey = await this.getOpenAIKey();
    
    return this.secureRequest('/openai/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model,
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.7,
      }),
    });
  }

  private async getOpenAIKey(): Promise<string> {
    // APIã‚­ãƒ¼ã‚’å®‰å…¨ã«å–å¾—
    const key = await SecureStore.getItemAsync('openai_key');
    if (!key) {
      throw new Error('OpenAI API key not found');
    }
    return key;
  }
}

export const secureApiClient = new SecureApiClient(
  'https://api.climbYou.app',
  'sha256/XXXXXX' // å®Ÿéš›ã®è¨¼æ˜æ›¸ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ
);
```

### 4.2 ãƒªã‚¯ã‚¨ã‚¹ãƒˆèªè¨¼ãƒ»ç½²å

```typescript
// utils/requestSigning.ts
class RequestSigner {
  // ãƒªã‚¯ã‚¨ã‚¹ãƒˆç½²åã®ç”Ÿæˆ
  async signRequest(
    method: string,
    url: string,
    body: string | null,
    timestamp: string,
    userId: string
  ): Promise<string> {
    const signingKey = await this.getSigningKey(userId);
    
    // ç½²åå¯¾è±¡æ–‡å­—åˆ—ã®æ§‹ç¯‰
    const signatureBase = [
      method.toUpperCase(),
      url,
      body || '',
      timestamp,
      userId,
    ].join('\n');
    
    // HMAC-SHA256ã§ç½²å
    const signature = await encryptionService.hashData(
      signatureBase,
      signingKey
    );
    
    return signature;
  }

  // ãƒªã‚¯ã‚¨ã‚¹ãƒˆç½²åã®æ¤œè¨¼
  async verifyRequest(
    signature: string,
    method: string,
    url: string,
    body: string | null,
    timestamp: string,
    userId: string
  ): Promise<boolean> {
    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®æ¤œè¨¼ï¼ˆ5åˆ†ä»¥å†…ï¼‰
    const now = Date.now();
    const requestTime = parseInt(timestamp);
    if (Math.abs(now - requestTime) > 5 * 60 * 1000) {
      return false;
    }
    
    // ç½²åã®å†è¨ˆç®—ãƒ»æ¤œè¨¼
    const expectedSignature = await this.signRequest(
      method,
      url,
      body,
      timestamp,
      userId
    );
    
    return signature === expectedSignature;
  }

  private async getSigningKey(userId: string): Promise<string> {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼å›ºæœ‰ã®ç½²åã‚­ãƒ¼ã‚’ç”Ÿæˆ
    return encryptionService.getDerivedKey(`signing_${userId}`);
  }
}

export const requestSigner = new RequestSigner();
```

## 5. ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·

### 5.1 ãƒ‡ãƒ¼ã‚¿åŒ¿ååŒ–

```typescript
// services/privacy/anonymization.ts
class DataAnonymizationService {
  // å€‹äººè­˜åˆ¥æƒ…å ±ã®åŒ¿ååŒ–
  anonymizeUserData(data: any): any {
    const anonymized = { ...data };
    
    // PIIè¦ç´ ã‚’åŒ¿ååŒ–
    if (anonymized.email) {
      anonymized.email = this.hashEmail(anonymized.email);
    }
    
    if (anonymized.name) {
      anonymized.name = this.anonymizeName(anonymized.name);
    }
    
    if (anonymized.birthDate) {
      anonymized.age = this.calculateAge(anonymized.birthDate);
      delete anonymized.birthDate;
    }
    
    if (anonymized.location) {
      anonymized.region = this.generalizeLocation(anonymized.location);
      delete anonymized.location;
    }
    
    // ä¸€æ„è­˜åˆ¥å­ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
    if (anonymized.userId) {
      anonymized.userId = this.hashUserId(anonymized.userId);
    }
    
    return anonymized;
  }

  // OpenAIé€ä¿¡ç”¨ãƒ‡ãƒ¼ã‚¿ã®åŒ¿ååŒ–
  anonymizeForAI(learningData: any): any {
    const sanitized = {
      learningStyle: learningData.learningStyle,
      goals: learningData.goals?.map((goal: any) => ({
        category: goal.category,
        difficulty: goal.difficulty,
        timeframe: goal.timeframe,
        // å…·ä½“çš„ãªå†…å®¹ã¯é™¤å¤–
      })),
      completionHistory: learningData.completionHistory?.map((entry: any) => ({
        category: entry.category,
        difficulty: entry.difficulty,
        completionTime: entry.completionTime,
        satisfaction: entry.satisfaction,
        // å…·ä½“çš„ãªã‚¯ã‚¨ã‚¹ãƒˆå†…å®¹ã¯é™¤å¤–
      })),
      preferences: learningData.preferences,
    };
    
    return sanitized;
  }

  private hashEmail(email: string): string {
    return encryptionService.hashData(email, 'email_salt');
  }

  private anonymizeName(name: string): string {
    return name.charAt(0) + '***';
  }

  private calculateAge(birthDate: string): number {
    const birth = new Date(birthDate);
    const today = new Date();
    return today.getFullYear() - birth.getFullYear();
  }

  private generalizeLocation(location: string): string {
    // éƒ½é“åºœçœŒãƒ¬ãƒ™ãƒ«ã¾ã§ä¸€èˆ¬åŒ–
    return location.split(',')[0] || 'Unknown';
  }

  private async hashUserId(userId: string): Promise<string> {
    return encryptionService.hashData(userId, 'user_id_salt');
  }
}

export const anonymizationService = new DataAnonymizationService();
```

### 5.2 ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ãƒ»å¿˜ã‚Œã‚‰ã‚Œã‚‹æ¨©åˆ©

```typescript
// services/privacy/dataErasure.ts
class DataErasureService {
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å®Œå…¨å‰Šé™¤
  async eraseUserData(userId: string): Promise<void> {
    try {
      // 1. Firestoreä¸Šã®ãƒ‡ãƒ¼ã‚¿å‰Šé™¤
      await this.deleteFirestoreData(userId);
      
      // 2. ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®å‰Šé™¤
      await this.deleteLocalData(userId);
      
      // 3. åˆ†æãƒ‡ãƒ¼ã‚¿ã®åŒ¿ååŒ–
      await this.anonymizeAnalyticsData(userId);
      
      // 4. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ã®å‰Šé™¤è¦æ±‚
      await this.requestBackupDeletion(userId);
      
      // 5. ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®å‰Šé™¤è¦æ±‚
      await this.requestThirdPartyDeletion(userId);
      
      // å‰Šé™¤å®Œäº†ãƒ­ã‚°
      console.log(`Data erasure completed for user: ${userId}`);
    } catch (error) {
      console.error('Data erasure failed:', error);
      throw new Error('Failed to complete data erasure');
    }
  }

  // ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ã®é€²æ—ç¢ºèª
  async verifyErasure(userId: string): Promise<ErasureStatus> {
    const checks = await Promise.allSettled([
      this.checkFirestoreErasure(userId),
      this.checkLocalErasure(userId),
      this.checkAnalyticsErasure(userId),
    ]);
    
    return {
      firestore: checks[0].status === 'fulfilled' && checks[0].value,
      local: checks[1].status === 'fulfilled' && checks[1].value,
      analytics: checks[2].status === 'fulfilled' && checks[2].value,
      completedAt: new Date(),
    };
  }

  private async deleteFirestoreData(userId: string): Promise<void> {
    const batch = db.batch();
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚µãƒ–ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤
    const collections = [
      'dailyQuests',
      'completedQuests',
      'aiInsights',
      'goals',
      'learningHistory',
    ];
    
    for (const collectionName of collections) {
      const snapshot = await db
        .collection('users')
        .doc(userId)
        .collection(collectionName)
        .get();
      
      snapshot.docs.forEach(doc => {
        batch.delete(doc.ref);
      });
    }
    
    // ãƒ¡ã‚¤ãƒ³ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤
    batch.delete(db.collection('users').doc(userId));
    
    await batch.commit();
  }

  private async deleteLocalData(userId: string): Promise<void> {
    const keysToDelete = [
      `secure_user_profile_${userId}`,
      `secure_learning_data_${userId}`,
      `secure_quest_cache_${userId}`,
      'user_token',
      'biometric_enabled',
      'device_id',
    ];
    
    await Promise.all(
      keysToDelete.map(key => 
        SecureStore.deleteItemAsync(key).catch(() => {})
      )
    );
    
    // AsyncStorageã‹ã‚‰ã‚‚å‰Šé™¤
    await AsyncStorage.multiRemove([
      'user-store',
      'quest-store',
      'ai-store',
      'notification-store',
    ]);
  }

  private async anonymizeAnalyticsData(userId: string): Promise<void> {
    // åˆ†æãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼è­˜åˆ¥æƒ…å ±ã‚’åŒ¿ååŒ–
    // å®Œå…¨å‰Šé™¤ã§ã¯ãªãçµ±è¨ˆçš„ä¾¡å€¤ã‚’ä¿æŒ
    await fetch('/api/analytics/anonymize', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ userId }),
    });
  }

  private async requestBackupDeletion(userId: string): Promise<void> {
    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ ã«å‰Šé™¤è¦æ±‚
    await fetch('/api/backup/delete', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ userId }),
    });
  }

  private async requestThirdPartyDeletion(userId: string): Promise<void> {
    // OpenAIç­‰ã®ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã«å‰Šé™¤è¦æ±‚
    // æ³¨æ„: OpenAIã¯è‡ªå‹•å‰Šé™¤ã«å¯¾å¿œã—ã¦ã„ãªã„å ´åˆãŒã‚ã‚‹ãŸã‚ã€
    // ãƒ‡ãƒ¼ã‚¿é€ä¿¡æ™‚ã«åŒ¿ååŒ–ã™ã‚‹ã“ã¨ãŒé‡è¦
    console.log(`Third-party deletion requested for user: ${userId}`);
  }
}

interface ErasureStatus {
  firestore: boolean;
  local: boolean;
  analytics: boolean;
  completedAt: Date;
}

export const dataErasureService = new DataErasureService();
```

## 6. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ãƒ»ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ

### 6.1 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆç›£è¦–

```typescript
// services/security/securityMonitor.ts
class SecurityMonitor {
  private suspiciousActivities: SecurityEvent[] = [];
  private readonly MAX_LOGIN_ATTEMPTS = 5;
  private readonly LOCKOUT_DURATION = 15 * 60 * 1000; // 15åˆ†
  private lockoutMap = new Map<string, Date>();

  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã®è¨˜éŒ²
  logSecurityEvent(event: SecurityEvent): void {
    this.suspiciousActivities.push(event);
    
    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è„…å¨æ¤œçŸ¥
    this.detectThreats(event);
    
    // ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¤–éƒ¨ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã«é€ä¿¡
    this.reportSecurityEvent(event);
  }

  // è„…å¨æ¤œçŸ¥
  private detectThreats(event: SecurityEvent): void {
    switch (event.type) {
      case 'failed_login':
        this.handleFailedLogin(event);
        break;
      case 'suspicious_activity':
        this.handleSuspiciousActivity(event);
        break;
      case 'data_access_anomaly':
        this.handleDataAccessAnomaly(event);
        break;
    }
  }

  private handleFailedLogin(event: SecurityEvent): void {
    const identifier = event.userId || event.ipAddress || 'unknown';
    const recentAttempts = this.getRecentFailedAttempts(identifier);
    
    if (recentAttempts >= this.MAX_LOGIN_ATTEMPTS) {
      // ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
      this.lockoutMap.set(identifier, new Date(Date.now() + this.LOCKOUT_DURATION));
      
      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡
      this.sendSecurityAlert({
        type: 'account_lockout',
        severity: 'high',
        details: {
          identifier,
          attempts: recentAttempts,
          timestamp: new Date(),
        },
      });
    }
  }

  private handleSuspiciousActivity(event: SecurityEvent): void {
    // ç•°å¸¸ãªã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œçŸ¥
    const patterns = this.analyzeAccessPatterns(event.userId!);
    
    if (patterns.isAnomalous) {
      this.sendSecurityAlert({
        type: 'suspicious_access',
        severity: 'medium',
        details: {
          userId: event.userId,
          patterns,
          timestamp: new Date(),
        },
      });
    }
  }

  // ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã®ãƒã‚§ãƒƒã‚¯
  isLockedOut(identifier: string): boolean {
    const lockoutTime = this.lockoutMap.get(identifier);
    if (!lockoutTime) return false;
    
    if (Date.now() > lockoutTime.getTime()) {
      this.lockoutMap.delete(identifier);
      return false;
    }
    
    return true;
  }

  private getRecentFailedAttempts(identifier: string): number {
    const oneHourAgo = Date.now() - 60 * 60 * 1000;
    return this.suspiciousActivities.filter(event => 
      event.type === 'failed_login' &&
      (event.userId === identifier || event.ipAddress === identifier) &&
      event.timestamp.getTime() > oneHourAgo
    ).length;
  }

  private analyzeAccessPatterns(userId: string): AccessPatternAnalysis {
    const userEvents = this.suspiciousActivities
      .filter(e => e.userId === userId)
      .slice(-50); // æœ€æ–°50ä»¶ã‚’åˆ†æ
    
    // ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œçŸ¥ãƒ­ã‚¸ãƒƒã‚¯
    const timeIntervals = this.calculateTimeIntervals(userEvents);
    const locationChanges = this.detectLocationChanges(userEvents);
    const deviceChanges = this.detectDeviceChanges(userEvents);
    
    return {
      isAnomalous: 
        timeIntervals.hasAnomalousPatterns ||
        locationChanges.isRapidChange ||
        deviceChanges.isSuspicious,
      details: {
        timeIntervals,
        locationChanges,
        deviceChanges,
      },
    };
  }

  private async sendSecurityAlert(alert: SecurityAlert): Promise<void> {
    // ç®¡ç†è€…ã¸ã®é€šçŸ¥
    console.warn('ğŸš¨ Security Alert:', alert);
    
    // å¤–éƒ¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®é€šçŸ¥
    try {
      await fetch('/api/security/alerts', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${await this.getSecurityToken()}`,
        },
        body: JSON.stringify(alert),
      });
    } catch (error) {
      console.error('Failed to send security alert:', error);
    }
  }
}

interface SecurityEvent {
  type: string;
  userId?: string;
  ipAddress?: string;
  userAgent?: string;
  timestamp: Date;
  details?: any;
}

interface SecurityAlert {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  details: any;
}

interface AccessPatternAnalysis {
  isAnomalous: boolean;
  details: any;
}

export const securityMonitor = new SecurityMonitor();
```